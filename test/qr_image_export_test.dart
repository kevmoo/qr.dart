import 'dart:io';
import 'dart:typed_data';

import 'package:image/image.dart' as img;
import 'package:path/path.dart' as p;
import 'package:qr/qr.dart';

import 'package:test/test.dart';

void main() {
  group('QrImageExporter', () {
    late Directory testOutputDir;

    // Set up a temporary directory for test output files.
    setUp(() {
      final currentDir = Directory.current;
      testOutputDir = Directory(p.join(currentDir.path, 'test_output'));
      if (!testOutputDir.existsSync()) {
        testOutputDir.createSync(recursive: true);
      }
    });

    // Clean up the temporary directory after all tests in this group have run.
    tearDown(() {
      // if (testOutputDir.existsSync()) {
      //   testOutputDir.deleteSync(recursive: true);
      // }
    });

    test('should export a basic QR code to PNG bytes', () {
      const qrData = 'https://pub.dev/packages/qr';
      final qrCode = QrCode.fromData(
        data: qrData,
        errorCorrectLevel: QrErrorCorrectLevel.M,
      );
      final qrImage = QrImage(qrCode);

      const moduleSize = 5;
      const margin = 25;

      // Generate PNG bytes for the QR code.
      final Uint8List? pngBytes = qrImage.toPngBytes(
        moduleSize: moduleSize,
        margin: margin,
      );

      // Verify that PNG bytes are generated.
      expect(pngBytes, isNotNull);
      expect(pngBytes!.isNotEmpty, isTrue);

      // Decode the generated bytes back to an image for content verification.
      final img.Image? decodedImage = img.decodePng(pngBytes);
      expect(decodedImage, isNotNull);

      // Calculate the expected image dimensions based on QR code properties.
      final expectedWidth = (qrImage.moduleCount * moduleSize) + (margin * 2);
      final expectedHeight = (qrImage.moduleCount * moduleSize) + (margin * 2);

      // Assert that the decoded image dimensions match the expected size.
      expect(decodedImage!.width, equals(expectedWidth));
      expect(decodedImage.height, equals(expectedHeight));

      // Save the generated image to a file for manual inspection.
      final filePath = p.join(testOutputDir.path, 'test_qrcode_basic.png');
      File(filePath).writeAsBytesSync(pngBytes);
      // print('Generated QR code image: $filePath'); // Comment out for cleaner test output
    });

    test('should handle different colors and sizes', () {
      const qrData = 'https://github.com/kevmoo/qr.dart';
      final qrCode = QrCode.fromData(
        data: qrData,
        errorCorrectLevel: QrErrorCorrectLevel.L,
      );
      final qrImage = QrImage(qrCode);

      const moduleSize = 2;
      const margin = 10;

      // Generate PNG bytes with custom colors and sizes.
      final Uint8List? pngBytes = qrImage.toPngBytes(
        moduleSize: moduleSize,
        margin: margin,
        darkColor: 0xFF0000FF, // Blue
        lightColor: 0xFFFFFF00, // Yellow
      );

      // Verify that PNG bytes are generated.
      expect(pngBytes, isNotNull);
      expect(pngBytes!.isNotEmpty, isTrue);

      // Decode the generated bytes back to an image for content verification.
      final img.Image? decodedImage = img.decodePng(pngBytes);
      expect(decodedImage, isNotNull);

      // Calculate the expected image dimensions based on QR code properties.
      final expectedWidth = (qrImage.moduleCount * moduleSize) + (margin * 2);
      final expectedHeight = (qrImage.moduleCount * moduleSize) + (margin * 2);

      // Assert that the decoded image dimensions match the expected size.
      expect(decodedImage!.width, equals(expectedWidth));
      expect(decodedImage.height, equals(expectedHeight));

      // Save the generated image to a file for manual inspection.
      final filePath = p.join(testOutputDir.path, 'test_qrcode_colored.png');
      File(filePath).writeAsBytesSync(pngBytes);
      // print('Generated colored QR code image: $filePath'); // Comment out for cleaner test output
    });

    test('should export an empty QR code to PNG bytes', () {
      const qrData = ''; // Empty string
      final qrCode = QrCode.fromData(
        data: qrData,
        errorCorrectLevel: QrErrorCorrectLevel.M,
      );
      final qrImage = QrImage(qrCode);

      const moduleSize = 5;
      const margin = 25;

      final Uint8List? pngBytes = qrImage.toPngBytes(
        moduleSize: moduleSize,
        margin: margin,
      );

      expect(pngBytes, isNotNull);
      expect(pngBytes!.isNotEmpty, isTrue);

      final img.Image? decodedImage = img.decodePng(pngBytes);
      expect(decodedImage, isNotNull);

      // For empty data, QrCode should generate Version 1, which has moduleCount of 21.
      final expectedWidth = (qrImage.moduleCount * moduleSize) + (margin * 2);
      final expectedHeight = (qrImage.moduleCount * moduleSize) + (margin * 2);
      // 21 * 5 + (25 * 2) = 105 + 50 = 155
      expect(decodedImage!.width, equals(expectedWidth));
      expect(decodedImage.height, equals(expectedHeight));

      final filePath = p.join(testOutputDir.path, 'test_qrcode_empty.png');
      File(filePath).writeAsBytesSync(pngBytes);
    });
  });
}
